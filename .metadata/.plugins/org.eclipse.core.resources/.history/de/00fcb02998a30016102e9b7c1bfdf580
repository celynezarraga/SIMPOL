import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.io.*;
import java.lang.Object.*;
import java.util.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionListener;
import java.awt.event.*;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;

public class simpol extends JPanel{

	JFrame frame = new JFrame("SIMPOL: Simple Interpreter");
	
	Container overallFrame = new Container();
	Container overall1 = new Container();
	Container overall1a = new Container();
	Container overall1b = new Container();
	Container overall1c = new Container();
	Container overall2 = new Container();
	Container overall3a = new Container();
	Container overall3b = new Container();
	
	DefaultTableModel symbolTable;
	DefaultTableModel lexemeTable;
	JTextArea inputText;
	JTextArea consoleText;
	Boolean hasError = false;
	Boolean variableStart = false;
	Boolean codeStart = false;
	int codeIndex;

	HashMap<String,String> reservedWords = new HashMap<String,String>();
	HashMap<String,String> variablesTypes = new HashMap<String,String>();
	HashMap<String,String> variablesValues = new HashMap<String,String>();
	ArrayList<String> symbolsInTable = new ArrayList<String>();
	
	public simpol(){
		renderFrame();
		addLabelsAndContainers();
		packFrame();
	}

	public static void main(String[] args){
		simpol simleInterpreter = new simpol();
	}

	public void renderFrame(){
		frame.setSize(new Dimension (1500,700));						//frame
		frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE);
		
		overallFrame.setPreferredSize(new Dimension(1500, 700));
		overallFrame.setLayout(new FlowLayout(FlowLayout.CENTER));
		
		overall1.setPreferredSize(new Dimension(1500,350));
		overall1.setLayout(new GridLayout(1,3,2,2));
		
		overall2.setPreferredSize(new Dimension(1500,50));
		overall2.setLayout(new FlowLayout(FlowLayout.CENTER));
		
		overall3a.setPreferredSize(new Dimension(1500,25));
		overall3a.setLayout(new FlowLayout(FlowLayout.LEFT));
		
		overall3b.setPreferredSize(new Dimension(1500,375));
		overall3b.setLayout(new FlowLayout(FlowLayout.CENTER));
		
		overall1a.setPreferredSize(new Dimension(300,350));
		overall1a.setLayout(new FlowLayout(FlowLayout.CENTER));
		
		overall1b.setPreferredSize(new Dimension(650,350));
		overall1b.setLayout(new FlowLayout(FlowLayout.CENTER));
		
		overall1c.setPreferredSize(new Dimension(550,350));
		overall1c.setLayout(new FlowLayout(FlowLayout.CENTER));
	
	
	}

	public void readFile(File fileToRead){
		try (BufferedReader br = new BufferedReader(new FileReader(fileToRead))) {

			String line;
															
			while ((line = br.readLine()) != null) {		//read per line
				String current = inputText.getText();
				inputText.setText(current.concat(line + "\n"));
			}

		} catch (IOException e) {
				e.printStackTrace();
		}
	}
	
	public void initializeReservedWords(){
		reservedWords.put("variable", "Start of Variable Declaration");
		reservedWords.put("INT", "Data Type");
		reservedWords.put("BLN", "Data Type");
		reservedWords.put("STG", "Data Type");
		reservedWords.put("code", "Start of Code Segment");
		reservedWords.put("PRT", "Print Operator");
		reservedWords.put("ASK", "Ask Operator");
		reservedWords.put("PUT", "Assignment Operator");
		reservedWords.put("IN", "Assignment Operator");
		reservedWords.put("ADD", "Arithmetic Operator");
		reservedWords.put("SUB", "Arithmetic Operator");
		reservedWords.put("MUL", "Arithmetic Operator");
		reservedWords.put("DIV", "Arithmetic Operator");
		reservedWords.put("MOD", "Arithmetic Operator");
		reservedWords.put("GRT", "Numeric Predicate");
		reservedWords.put("GRE", "Numeric Predicate");
		reservedWords.put("LET", "Numeric Predicate");
		reservedWords.put("LEE", "Numeric Predicate");
		reservedWords.put("EQL", "Numeric Predicate");
		reservedWords.put("AND", "Logical Operator");
		reservedWords.put("OHR", "Logical Operator");
		reservedWords.put("NON", "Logical Operator");
		reservedWords.put("{", "Left Curly Brace");
		reservedWords.put("}", "Right Curly Brace");
	}
	
	public void interpretInput(){
		hasError = false;
		initializeReservedWords();
		
		String input = inputText.getText();
		
		if(input.length() != 0){
			if(input.contains("}")){
				String[] segment = new String[2];
				if((input.indexOf("}")+1) < input.length()){
					segment[0] = input.substring(0, input.indexOf("}")+1);
					segment[1] = input.substring(input.indexOf("}")+1);
					
					processVariableSegment(segment[0]);
					if(!hasError){
						processCodeSegment(segment[1]);
					}
				}
				else{
					print("Error: Incomplete Segments!");
				}
				
			}
			else{
				print("Error: No complete segment in code. '}' missing.");
			}
		}
		else{
			print("Error: Empty Input. Choose a file, or enter your code.");
		}

	}
	
	public void print(String toPrint){
		consoleText.setText(consoleText.getText().concat(toPrint + "\n"));
	}
	
	public void processVariableSegment(String varSegment){
		String[] lines = varSegment.split("\\s");
		
		if(lines[0].equals("variable") && variableStart==false){
			lexemeTable.addRow(new Object[]{lines[0], reservedWords.get(lines[0])});
			
			if(lines[1].equals("{")){
				lexemeTable.addRow(new Object[]{lines[1], reservedWords.get(lines[1])});
				
				int index = 2;
				while((index<lines.length) && !(lines[index].equals("}"))){
					
					if(reservedWords.containsKey(lines[index])){
						switch(lines[index]){
							case "INT": 
							case "BLN": 
							case "STG":	lexemeTable.addRow(new Object[]{lines[index], reservedWords.get(lines[index])});
										if(!(reservedWords.containsKey(lines[index+1])) && !(variablesTypes.containsKey(lines[index+1]))){
											lexemeTable.addRow(new Object[]{lines[index+1], "Variable Name"});
											symbolTable.addRow(new Object[]{lines[index+1], lines[index], "null"});
											variablesTypes.put(lines[index+1], lines[index]);
											variablesValues.put(lines[index+1], "null");
											symbolsInTable.add(lines[index+1]);
										}
										else{
											if(variablesTypes.containsKey(lines[index+1])){
												print("Error: Variable name already exists ->  ".concat(lines[index+1]));
											}
											else{
												print("Error: Invalid variable name ->  ".concat(lines[index+1]));
											}
											hasError = true;
											return;
										}
										break;
							default:	print("Error: Invalid data type -> ".concat(lines[index]));
										hasError = true;
										return;
						}
					}
					else{
						print("Error: Invalid data type -> ".concat(lines[index]));
						hasError = true;
						return;
					}
					index+=2;
				}
				if(lines[index].equals("}")){
					lexemeTable.addRow(new Object[]{lines[index], reservedWords.get(lines[index])});
				}
				else{
					print("Error: No right curly brace found to end variable declaration segment properly.");
					hasError = true;
					return;
				}
			}
			else{
				print("Error: No left curly brace found after start of variable declaration segment.");
				hasError = true;
				return;
			}
		}
		else{
			if(variableStart){
				print("Error: Multiple start of variable declaration segment found.");
			}
			else{
				print("Error: No start of variable declaration segment found.");
			}
			hasError = true;
			return;
		}
	}
	
	public void addLabelsAndContainers(){
		JButton browseFileButton = new JButton("Select file");
		
		ActionListener chooseFileButton = new ActionListener(){
			public void actionPerformed(ActionEvent e){
		       	JFileChooser chooser= new JFileChooser();
		       	FileNameExtensionFilter filter = new FileNameExtensionFilter("Text Files", "sim");
				chooser.setFileFilter(filter);

				int choice = chooser.showOpenDialog(simpol.this);
				if (choice != JFileChooser.APPROVE_OPTION){
					System.out.println("File reading cancelled.");
				}
				else{
					File chosenFile = chooser.getSelectedFile();
					readFile(chosenFile);							//read file	
		    	}
		    }
		};

		browseFileButton.addActionListener(chooseFileButton);
		overall1a.add(browseFileButton);
		
		inputText = new JTextArea(450,275);										//input field
		inputText.setLineWrap(true);
		inputText.setWrapStyleWord(true);
		JScrollPane areaScrollPane = new JScrollPane(inputText);
		areaScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
		areaScrollPane.setPreferredSize(new Dimension(450, 275));
		overall1a.add(areaScrollPane);
		
		JButton clearButton = new JButton("Clear");
		
		ActionListener clearText = new ActionListener(){
			public void actionPerformed(ActionEvent e){
		       	inputText.setText("");
		    }
		};
		
		clearButton.addActionListener(clearText);
		overall1a.add(clearButton);
		
		JLabel symTable_label = new JLabel("SYMBOL TABLE");
		overall1b.add(symTable_label);
		
		String[] colHeadings1 = {"VAR","TYPE","VALUE"};
		int numRows1 = 0 ;
		symbolTable = new DefaultTableModel(numRows1, colHeadings1.length);
		symbolTable.setColumnIdentifiers(colHeadings1);
		JTable table1 = new JTable(symbolTable);

		table1.setPreferredScrollableViewportSize(new Dimension(450,300));
		table1.setEnabled(false);
		overall1b.add(table1);
		overall1b.add(new JScrollPane(table1));
		
		JLabel lexTable_label = new JLabel("TOKENS/LEXEMES");
		overall1c.add(lexTable_label);
		
		String[] colHeadings2 = {"TOKEN","LEXEME"};
		int numRows2 = 0 ;
		lexemeTable = new DefaultTableModel(numRows2, colHeadings2.length);
		lexemeTable.setColumnIdentifiers(colHeadings2);
		JTable table2 = new JTable(lexemeTable);

		table2.setPreferredScrollableViewportSize(new Dimension(450,300));
		table2.setEnabled(false);
		overall1c.add(table2);
		overall1c.add(new JScrollPane(table2));
		
		JButton executeButton = new JButton("EXECUTE");
		executeButton.setPreferredSize(new Dimension(1450, 50));
		
		ActionListener exec = new ActionListener(){
			public void actionPerformed(ActionEvent e){
		       	interpretInput();
		    }
		};
		
		executeButton.addActionListener(exec);
		overall2.add(executeButton);
		
		JLabel console_label = new JLabel("CONSOLE");
		overall3a.add(console_label);
		
		consoleText = new JTextArea(1450,225);
		consoleText.setEditable(false);
		consoleText.setLineWrap(true);
		consoleText.setWrapStyleWord(true);
		JScrollPane areaScrollPane1 = new JScrollPane(consoleText);
		areaScrollPane1.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
		areaScrollPane1.setPreferredSize(new Dimension(1450, 225));
		overall3b.add(areaScrollPane1);
	}

	public void packFrame(){
		overall1.add(overall1a);
		overall1.add(overall1b);
		overall1.add(overall1c);
		
		overallFrame.add(overall1);
		overallFrame.add(overall2);
		overallFrame.add(overall3a);
		overallFrame.add(overall3b);
		
		frame.getContentPane().setBackground(Color.gray);

		frame.add(overallFrame);
		frame.pack();
		frame.setVisible(true);
	}

	public void processCodeSegment(String codeSegment){
		String[] lines = codeSegment.split("\\s");
		int x;
		Boolean temp;
		
		if(lines[0].equals("code") && codeStart==false){
			lexemeTable.addRow(new Object[]{lines[0], reservedWords.get(lines[0])});
			
			if(lines[1].equals("{")){
				lexemeTable.addRow(new Object[]{lines[1], reservedWords.get(lines[1])});
				
				codeIndex = 2;
				while((codeIndex<lines.length) && !(lines[codeIndex].equals("}")) && !(hasError)){
					if(reservedWords.containsKey(lines[codeIndex])){
						switch(lines[codeIndex]){
							case "PRT": printingOperation(lines);
										break;
							case "ASK": scanningOperation(lines);
										break;
							case "PUT": assignOperation(lines);
										break;
							case "ADD": x = add(lines);
										break;
							case "SUB": x = subtract(lines);
										break;
							case "MUL": x = multiply(lines);
										break;
							case "DIV": x = divide(lines);
										break;
							case "MOD": x = modulo(lines);
										break;
							// case "GRT": x = greaterThan(lines);
							// 			break;
							// case "GRE": x = greaterThanEqual(lines);
							// 			break;
							// case "LET": x = lessThan(lines);
							// 			break;
							// case "LEE": x = lessThanEqual(lines);
							// 			break;
							// case "EQL": x = equalOperation(lines);
							// 			break;
							// case "AND": x = andOperation(lines);
							// 			break;
							// case "OHR": x = orOperation(lines);
							// 			break; 
							// case "NON": x = notOperation(lines);
										break;
							default: print("Error: Invalid Operator!");
									 hasError = true;
									 return;
						}
					}
					else{
						print("Error: Invalid Operator!");
						hasError = true;
						return;
					}
				}
				if(lines[codeIndex].equals("}")){
					lexemeTable.addRow(new Object[]{lines[codeIndex], reservedWords.get(lines[codeIndex])});
				}
				else{
					print("Error: No right curly brace found to end code segment properly.");
					hasError = true;
					return;
				}
			}
			else{
				print("Error: No left curly brace found after start of code segment.");
				hasError = true;
				return;
			}
		}
		else{
			if(codeStart){
				print("Error: Multiple start of code segment found.");
			}
			else{
				print("Error: No start of code segment found.");
			}
			hasError = true;
			return;
		}
	}

	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
	public void assignOperation(String[] lines){
		if(!hasError){
			if(lines[codeIndex].equals("PUT")){
				lexemeTable.addRow(new Object[]{lines[codeIndex], reservedWords.get(lines[codeIndex])});
				codeIndex++;

				while((lines[codeIndex].equals("IN")) && (codeIndex<lines.length)){
				//compute or get value to assign!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				}
				if(lines[codeIndex].equals("IN")){
					lexemeTable.addRow(new Object[]{lines[codeIndex], reservedWords.get(lines[codeIndex])});
					codeIndex++;
					if((codeIndex<lines.length) && (variablesTypes.containsKey(lines[codeIndex]))){
						lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
						//assign value!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
						codeIndex++;
					}
					else{
						if(!variablesTypes.containsKey(lines[codeIndex])){
							print("Error: Variable name '".concat(lines[codeIndex] + "' was not declared."));
						}
						else{
							print("Error: No variable found where value will be assigned.");
						}
						hasError = true;
						return;	
					}
				}
				else{
					hasError = true;
					print("Error: No 'IN' found after 'PUT' operator.");
				}
			}
		}
		return;
	}

	public void scanningOperation(String[] lines){
		if(!hasError){
			if(lines[codeIndex].equals("ASK")){
				lexemeTable.addRow(new Object[]{lines[codeIndex], reservedWords.get(lines[codeIndex])});
				codeIndex++;

				if((codeIndex<lines.length) && (variablesTypes.containsKey(lines[codeIndex]))){
					lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});

					switch(variablesTypes.get(lines[codeIndex])){
						case "INT": String dialogMessage = "Enter value to be assigned to ".concat("variable" + lines[codeIndex] + "(Integer) :");
									String value= JOptionPane.showInputDialog(dialogMessage);
									print(value);
									codeIndex++;
									if(value.matches("-?\\d+(\\.\\d+)?")){
										int inputValue = Integer.parseInt(value);
										variablesValues.put(lines[codeIndex],String.valueOf(inputValue));
										symbolTable.setValueAt(String.valueOf(inputValue), symbolsInTable.get(lines[codeIndex]), 2);
									}
									else{
										print("Error: Invalid input.");
										hasError = true;
										return;
									}
									break;
						case "BLN": String dialogMessage = "Enter value to be assigned to ".concat("variable" + lines[codeIndex] + "(Boolean) :");
									String value= JOptionPane.showInputDialog(dialogMessage);
									print(value);
									codeIndex++;
									if((value.equals("true")) || (value.equals("false"))){
										variablesValues.put(lines[codeIndex],value);
										symbolTable.setValueAt(value, symbolsInTable.get(lines[codeIndex]), 2);
									}
									else{
										print("Error: Invalid input.");
										hasError = true;
										return;
									}
									break;
						case "STG": String dialogMessage = "Enter value to be assigned to ".concat("variable" + lines[codeIndex] + "(String) :");
									String value= JOptionPane.showInputDialog(dialogMessage);
									print(value);
									codeIndex++;
									if(value.matches("^\\$.*\\$$")){
										variablesValues.put(lines[codeIndex],value);
										symbolTable.setValueAt(value, symbolsInTable.get(lines[codeIndex]), 2);
									}
									else{
										print("Error: Invalid input.");
										hasError = true;
										return;
									}
									break;
						default:	break;
					}
				}
				else{
					if(!variablesTypes.containsKey(lines[codeIndex])){
						print("Error: Variable name '".concat(lines[codeIndex] + "' was not declared."));
					}
					else{
						print("Error: No variable found where value will be assigned.");
					}
					hasError = true;
					return;	
				}
			}
		}
		return;

	}

	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	public void printingOperation(String[] lines){
		if(!hasError){	
			if(lines[codeIndex].equals("PRT")){
				lexemeTable.addRow(new Object[]{lines[codeIndex], reservedWords.get(lines[codeIndex])});
				codeIndex++;

				if((codeIndex<lines.length) && (variablesTypes.containsKey(lines[codeIndex]))){
					lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});

					switch(variablesTypes.get(lines[codeIndex])){
						case "INT": print(variablesValues.get(lines[codeIndex]));
									codeIndex++;
									break;
						case "BLN": print(variablesValues.get(lines[codeIndex]));
									codeIndex++;
									break;
						case "STG": print(variablesValues.get(lines[codeIndex]));
									codeIndex++;
									break;
						default:	break;
					}
				}
				else{

					//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					//check if operation
					//check if string

					// if(!variablesTypes.containsKey(lines[codeIndex])){
					// 	print("Error: Variable name '".concat(lines[codeIndex] + "' was not declared."));
					// }
					// else{
					// 	print("Error: No variable found where value will be assigned.");
					// }
					// hasError = true;
					return;	
				}
			}
		}
		return;

	}

	public int add(String[] lines){
		int value,operand1, operand2 = 0;

		if(!hasError){
			if(lines[codeIndex].equals("ADD")){
				lexemeTable.addRow(new Object[]{lines[codeIndex], reservedWords.get(lines[codeIndex])});
				codeIndex++;

				if((codeIndex<lines.length) )){
					if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
						lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
						operand1 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
						codeIndex++;

						if((codeIndex<lines.length) ){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
						lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
						operand1 = Integer.parseInt(lines[codeIndex]);
						codeIndex++;

						if((codeIndex<lines.length) ){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else if(reservedWords.containsKey(lines[codeIndex])){
						switch(lines[codeIndex]){
							case "ADD": operand1 = add(lines);
										break;
							case "SUB": operand1 = subtract(lines);
										break;
							case "MUL": operand1 = multiply(lines);
										break;
							case "DIV": operand1 = divide(lines);
										break;
							case "MOD": operand1 = modulo(lines);
										break;
							default: print("Error: Invalid Operator!");
									 hasError = true;
									 return value;
						}

						if((codeIndex<lines.length) ){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else{
						print("Error: Invalid arguments for ADD operation.");
						hasError = true;
					}	
				}
				else{
					print("Error: Invalid arguments for ADD operation.");
					hasError = true;
				}
			}
		}

		value = operand1 + operand2;
		return value;
	}

	public int subtract(String[] lines){
		int value,operand1, operand2 = 0;

		if(!hasError){
			if(lines[codeIndex].equals("ADD")){
				lexemeTable.addRow(new Object[]{lines[codeIndex], reservedWords.get(lines[codeIndex])});
				codeIndex++;

				if((codeIndex<lines.length) ){
					if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
						lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
						operand1 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
						codeIndex++;

						if((codeIndex<lines.length) ){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
						lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
						operand1 = Integer.parseInt(lines[codeIndex]);
						codeIndex++;

						if((codeIndex<lines.length) )){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else if(reservedWords.containsKey(lines[codeIndex])){
						switch(lines[codeIndex]){
							case "ADD": operand1 = add(lines);
										break;
							case "SUB": operand1 = subtract(lines);
										break;
							case "MUL": operand1 = multiply(lines);
										break;
							case "DIV": operand1 = divide(lines);
										break;
							case "MOD": operand1 = modulo(lines);
										break;
							default: print("Error: Invalid Operator!");
									 hasError = true;
									 return value;
						}

						if((codeIndex<lines.length) )){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else{
						print("Error: Invalid arguments for ADD operation.");
						hasError = true;
					}	
				}
				else{
					print("Error: Invalid arguments for ADD operation.");
					hasError = true;
				}
			}
		}

		value = operand1 - operand2;
		return value;
	}

	public int multiply(String[] lines){
		int value,operand1, operand2 = 0;

		if(!hasError){
			if(lines[codeIndex].equals("ADD")){
				lexemeTable.addRow(new Object[]{lines[codeIndex], reservedWords.get(lines[codeIndex])});
				codeIndex++;

				if((codeIndex<lines.length) )){
					if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
						lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
						operand1 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
						codeIndex++;

						if((codeIndex<lines.length) )){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
						lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
						operand1 = Integer.parseInt(lines[codeIndex]);
						codeIndex++;

						if((codeIndex<lines.length) )){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else if(reservedWords.containsKey(lines[codeIndex])){
						switch(lines[codeIndex]){
							case "ADD": operand1 = add(lines);
										break;
							case "SUB": operand1 = subtract(lines);
										break;
							case "MUL": operand1 = multiply(lines);
										break;
							case "DIV": operand1 = divide(lines);
										break;
							case "MOD": operand1 = modulo(lines);
										break;
							default: print("Error: Invalid Operator!");
									 hasError = true;
									 return value;
						}

						if((codeIndex<lines.length) )){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else{
						print("Error: Invalid arguments for ADD operation.");
						hasError = true;
					}	
				}
				else{
					print("Error: Invalid arguments for ADD operation.");
					hasError = true;
				}
			}
		}

		value = operand1 * operand2;
		return value;
	}

	public int divide(String[] lines){
		int value,operand1, operand2 = 0;

		if(!hasError){
			if(lines[codeIndex].equals("ADD")){
				lexemeTable.addRow(new Object[]{lines[codeIndex], reservedWords.get(lines[codeIndex])});
				codeIndex++;

				if((codeIndex<lines.length) )){
					if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
						lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
						operand1 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
						codeIndex++;

						if((codeIndex<lines.length) )){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
						lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
						operand1 = Integer.parseInt(lines[codeIndex]);
						codeIndex++;

						if((codeIndex<lines.length) )){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else if(reservedWords.containsKey(lines[codeIndex])){
						switch(lines[codeIndex]){
							case "ADD": operand1 = add(lines);
										break;
							case "SUB": operand1 = subtract(lines);
										break;
							case "MUL": operand1 = multiply(lines);
										break;
							case "DIV": operand1 = divide(lines);
										break;
							case "MOD": operand1 = modulo(lines);
										break;
							default: print("Error: Invalid Operator!");
									 hasError = true;
									 return value;
						}

						if((codeIndex<lines.length) )){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else{
						print("Error: Invalid arguments for ADD operation.");
						hasError = true;
					}	
				}
				else{
					print("Error: Invalid arguments for ADD operation.");
					hasError = true;
				}
			}
		}

		value = operand1 / operand2;
		return value;
	}

	public int modulo(String[] lines){
		int value,operand1, operand2 = 0;

		if(!hasError){
			if(lines[codeIndex].equals("ADD")){
				lexemeTable.addRow(new Object[]{lines[codeIndex], reservedWords.get(lines[codeIndex])});
				codeIndex++;

				if((codeIndex<lines.length) )){
					if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
						lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
						operand1 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
						codeIndex++;

						if((codeIndex<lines.length) )){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
						lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
						operand1 = Integer.parseInt(lines[codeIndex]);
						codeIndex++;

						if((codeIndex<lines.length) )){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else if(reservedWords.containsKey(lines[codeIndex])){
						switch(lines[codeIndex]){
							case "ADD": operand1 = add(lines);
										break;
							case "SUB": operand1 = subtract(lines);
										break;
							case "MUL": operand1 = multiply(lines);
										break;
							case "DIV": operand1 = divide(lines);
										break;
							case "MOD": operand1 = modulo(lines);
										break;
							default: print("Error: Invalid Operator!");
									 hasError = true;
									 return value;
						}

						if((codeIndex<lines.length) )){
							if(variablesTypes.containsKey(lines[codeIndex]) && variablesTypes.get(lines[codeIndex]).equals("INT")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Variable"});
								operand2 = Integer.parseInt(variablesValues.get(lines[codeIndex]));
								codeIndex++;
							}
							else if(lines[codeIndex].matches("-?\\d+(\\.\\d+)?")){
								lexemeTable.addRow(new Object[]{lines[codeIndex], "Expression/Operand"});
								operand2 = Integer.parseInt(lines[codeIndex]);
								codeIndex++;
							}
							else if(reservedWords.containsKey(lines[codeIndex])){
								switch(lines[codeIndex]){
									case "ADD": operand2 = add(lines);
												break;
									case "SUB": operand2 = subtract(lines);
												break;
									case "MUL": operand2 = multiply(lines);
												break;
									case "DIV": operand2 = divide(lines);
												break;
									case "MOD": operand2 = modulo(lines);
												break;
									default: print("Error: Invalid Operator!");
											 hasError = true;
											 return value;
								}
							}
							else{
								print("Error: Invalid arguments for ADD operation.");
								hasError = true;
							}	
						}
					}
					else{
						print("Error: Invalid arguments for ADD operation.");
						hasError = true;
					}	
				}
				else{
					print("Error: Invalid arguments for ADD operation.");
					hasError = true;
				}
			}
		}

		value = operand1 % operand2;
		return value;
	}
}
